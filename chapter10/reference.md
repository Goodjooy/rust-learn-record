# 引用

虽然但是，只有所有权的情况下，对于代码书写非常膈应。因此，有了引用类型

---

在 rust 中，引用分为不可变引用与可变引用。

- 不可变引用格式如下 `& T` 其中`T` 是任意类型
  - 同一个变量可以同时存在多个可变引用
  - 当一个变量的可变引用仍然存在时，将不能创建不可变引用
- 可变引用格式如下 `&mut T` 其中 `T` 是任意类型
  - 同时只能有一个可变引用
  - 当有不可变引用存在时，将不能创建可变引用

可变引用可以用 `as` 转换为不可变引用

**注意** 引用类型本身也是一种类型。也就是说，引用具有类型的特征

- 不可变引用可以使用拷贝语义转移所有权，可变引用可以使用移动语义转移所有权
- 可以对一个引用创建引用，实现引用的引用

也就是说，以下代码是合法的

```rust
fn main() {
    let b: String = String::from("string");

    let c: &String = &b;
    let d: &&String = &c; // 引用的引用
    let e: &&&String = &d; // 引用的引用的引用

    let mut a: String = String::from("aab");
    let g: &mut String = &mut a; // 可变引用
    let h: &mut String = g; // 可变引用所有权转移

    let mut i: String = String::from("Abbc");
    let j: &mut String = &mut i; // 可变引用
    let k: &String = j as &String; // 可变引用所有权转移并转换为不可变引用

    println!("b {},c {} d {} e {} h {} ,k {}", b, c, d, e, h, k);
}
```

> **引用不能比引用的原始值有更长的生命周期**

通常情况下，编译器可以自动推导引用的生命周期，但是在某些情况下，我们需要手动提供生命周期标记。将在下一节[生命周期](./lifetime.md) 具体展开

# 为什么需要异步

在现在的大部分的编程语言里面，通常会提供多种多样的并行的程序方案。  
有系统线程、回调函数等，既然都有这样多样化的处理方案了，为什么还要再来一个
`asynchronous`编程？

依我个人所见，asynchronous 是更加轻量的线程，但是又不完全是。

考虑以下代码

```rust
let resp = http_get(url);
```

这段代码如果直接执行通常会阻塞当前线程直到接收到完整的响应体，在某些情况下
我们希望同时发起多个下载，以节约时间。那么就会把代码改成以下的样子：

```rust
let handle = std::thread::spawn{
    move || {
        let resp = http_get(url);
        // 处理响应
        ...
    }
};

// 做了一些其他事情
...
// 阻塞直到线程完成
handle.join().ok();
```

这样当然没有什么问题。但是每当我们发起一个请求时，都会创建一个系统线程。为了一次 http 请求而临时性创建一个线程来处理略有杀鸡用牛刀的意味。而且，在 http 请求的大部分的时间都是在等待请求完成。在某种意义上这浪费了计算机的资源

但是当我们使用 asynchronous 编程，我们使用语言内置调度器调度不同协程的运行。这样就可以节约系统线程调用的开销，和系统线程调度的性能损失。同时，由于协程的特性，我们可以在一个任务在等待时将其挂起，转而去执行其他任务。

```rust
async fn task(){
    ...
    let resp1 = async_get(url).await;
    let resp2 = async_post(url2).await;
    ...
}
```

如果我们能使用异步模式的代码，我们将可以充分利用系统资源。而由于 rust 的异步 runtime 由社区提供，将有可能提供各种各样的运行时。甚至在单片机上提供异步（底层使用中断）成为可能

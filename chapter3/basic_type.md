# 基本数据类型

- 整型

  | 类型名称 | 含义                 |
  | :------: | :------------------- |
  |   `i8`   | 8 位有符号整型       |
  |   `u8`   | 8 位无符号整型       |
  |  `i16`   | 16 位有符号整型      |
  |  `u16`   | 16 位无符号整型      |
  |  `i32`   | 32 位有符号整型      |
  |  `u32`   | 32 位无符号整型      |
  |  `i64`   | 64 位有符号整型      |
  |  `u64`   | 64 位无符号整型      |
  |  `i128`  | 128 位有符号整型     |
  |  `u128`  | 128 位无符号整型     |
  | `isize`  | 有符号整型(长度类型) |
  | `usize`  | 无符号整型(长度类型) |

  > `isize` 与 `usize` 与系统架构有关，通常用于表示数组等类型的长度

  - 在通常情况下，整型的运算是不会发生溢出的现象
    - 当运行状态为 `Debug` 模式时，rust 会将数值运算时出现的溢出视为异常而终止程序运行。如果溢出是预期的计算，可以使用 [`std::num::Wrapping`](https://doc.rust-lang.org/std/num/struct.Wrapping.html)来告知编译器溢出是预期的行为
        > 在 [代码模块化]() 中将进一步讨论包的引入
    - 当运行状态为 `Release` 模式时，计算的溢出将不会出现异常
      > 这个行为可以通过一定的配置更改
  - 整型可以在数字之间添加`_` 来提供更好的可读性;在类型末尾添加类型来指定数据类型（默认会推导为`i32`）

    ```rust
    114_145_1919u64
    ```

- 浮点数
  | 类型名称 | 含义 |
  | :------: | :---|
  | `f32` | 32 位浮点数（单精度浮点数） |
  | `f64` | 64 位浮点数（双精度浮点数） |

  - 与其他语言不同的是，浮点类型没有实现 [`std::cmp::Eq`](https://doc.rust-lang.org/std/cmp/trait.Eq.html) 或者 [`std::cmp::PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html) 这 2 个`trait`。因此，浮点数无法直接判定相等或者作为 Map 的 key，只能比较大小。这样处理简单地排除了由于浮点数精度问题带来的值不相等的问题
    > 在 [通过`trait`来重载运算符]() 中将进一步讨论 `std::ops` 中的运算符重载

- 布尔类型 `bool`
- 字符类型 `char`
  - 值得注意的是，rust 中的 char 采用的是 UTF-8 编码，这说明一个合法的`char`将会需要 1~4 个字节的空间，不过 char 使用的空间始终是 4 字节。因此，任何合法的 `char` 都是可以安全地转换为 `u32`，但是反过来不成立。显然，将一个`char` 转换为 `u8` 将会造成数据丢失。
  - 由于 `String` 内部使用 `Vec<u8>` 来实现,因此`String` 类型不允许直接进行切片，而 `&str` 类型 切片时如果将一个 UTF-8 字符拆开了，将会出现异常
    > 在 [智能指针与 Deref]() 中将进一步讨论`String`

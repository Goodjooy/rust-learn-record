# 可变与不可变：变量

在 rust 中，使用 `let` 来声明一个变量

```rust
let a = 1;
let b;
b = 3;
```

除非标记为 `let mut` 否则声明的变量将是不可被更改的
但是，如果声明变量后未赋值，可以进行一次赋值操作

以下代码可以通过编译

```rust
let a = 1;
let b = 2;
```

以下代码无法通过编译

```rust
let a = 1;
a += 1;
```

但是修改后将也可以通过编译

```rust
let mut a = 1;
a += 1;
```

> 请注意：`rust` 的不可变约束比如 `kotlin` 等的约束更强
> 不可变除了不能直接修改值本身，也不能调用需要 `&mut self` 的方法

使用 `let` 语句，可以覆盖原有的变量

```rust
let a=1;
let a=a+1;
```

以上代码可以通过编译，因为新的 `a` 覆盖了原来的 `a`

通常情况下，rust 可以自行进行类型推导，当然也可以提供显示类型
格式如下

```rust
let a : u32 = 11;
```

在以上代码中 `a` 是一个类型为 `u32` 的变量

有些时候，可以只提供类型的一部分信息，剩下的由 rust 自行推导
将可以这样写

```rust
let a : Result<_, usize> = Result::Ok(11u32)
```

> `Result<T,E>` 将在[异常处理]() 提及
> `Result<T,E>` 中 `<T,E>`是泛型参数，将在 [泛型、trait]() 中提及
